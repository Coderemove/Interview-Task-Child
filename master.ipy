import os
import runpy
import datetime
import platform
import sys
from contextlib import redirect_stdout, redirect_stderr
import subprocess
from tqdm import tqdm
import tkinter as tk
from tkinter import messagebox

def show_error(message):
    root = tk.Tk()
    root.withdraw()  
    messagebox.showerror("Dependency Error", message)
    root.destroy()

def check_dependencies():
    try:
        subprocess.run(['quarto', '--version'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("Quarto is installed.")
    except FileNotFoundError:
        show_error("Quarto is not installed and/or it is not present in the SYSTEM PATH variable. Please install Quarto before proceeding.")
        sys.exit(1)
    try:
        subprocess.run(['R', '--version'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("R is installed.")
    except FileNotFoundError:
        show_error("R is not installed and/or it is not present in the SYSTEM PATH variable. Please install R before proceeding.")
        sys.exit(1)
    
check_dependencies()

def get_cpu_name():
    try:
        output = subprocess.check_output(
            ["wmic", "cpu", "get", "Name"],
            stderr=subprocess.DEVNULL,
            universal_newlines=True
        )
        lines = output.strip().splitlines()
        if len(lines) >= 2:
            return lines[1].strip()
    except Exception:
        return platform.processor()
    return platform.processor()

def get_gpu_name():
    try:
        output = subprocess.check_output(
            "wmic path win32_VideoController get Name",
            shell=True,
            stderr=subprocess.DEVNULL,
            universal_newlines=True
        )
        lines = output.strip().splitlines()
        gpus = [line.strip() for line in lines[1:] if line.strip()]
        return ", ".join(gpus) if gpus else "N/A"
    except Exception:
        return "N/A"

def get_total_ram():
    try:
        output = subprocess.check_output(
            "wmic ComputerSystem get TotalPhysicalMemory",
            shell=True,
            stderr=subprocess.DEVNULL,
            universal_newlines=True
        )
        lines = output.strip().splitlines()
        if len(lines) >= 2:
            total_ram_bytes = int(lines[1].strip())
            total_ram_gb = total_ram_bytes / (1024**3)
            return f"{total_ram_gb:.2f} GB"
    except Exception:
        return "N/A"
    return "N/A"

def check_quarto_processes():
    try:
        tasks = subprocess.check_output(["tasklist", "/FI", "IMAGENAME eq quarto.exe"], universal_newlines=True)
        if "quarto.exe" in tasks.lower():
            consent = input(
                "Found running Quarto process(es) that may host a dashboard preview. "
                "Do you consent to close them? (y/N): "
            )
            if consent.strip().lower() == "y":
                subprocess.call(["taskkill", "/F", "/IM", "quarto.exe"])
                print("Closed all Quarto processes.")
            else:
                print("Quarto processes were not closed. They may interfere with the new dashboard preview.")
    except Exception as e:
        print(f"Error checking Quarto processes: {e}")

def main():
    master_start = datetime.datetime.now()
    current_dir = os.path.dirname(os.path.abspath(__file__))
    scripts_dir = os.path.join(current_dir, 'scripts')
    check_quarto_processes()
    
    ipy_files = [
        os.path.join(scripts_dir, 'clean.ipy'),
        os.path.join(scripts_dir, 'averageengagement.ipy'),
        os.path.join(scripts_dir, 'mediareach.ipy'),
        os.path.join(scripts_dir, 'reportgeneration.ipy'),
        os.path.join(scripts_dir, 'dashboardgeneration.ipy'),
        # Add more scripts in the desired order if needed.
    ]
    
    total_steps = 3 + len(ipy_files) + 1
    progress = tqdm(total=total_steps, desc="Master Script Progress", unit="step")
    
    log_dir = os.path.join(current_dir, 'log')
    os.makedirs(log_dir, exist_ok=True)
  
    log_files = sorted(
        [f for f in os.listdir(log_dir) if f.startswith("log_") and f.endswith(".txt")],
        key=lambda f: os.path.getmtime(os.path.join(log_dir, f))
    )
    if len(log_files) >= 10:
        consent_cleanup = input(
            f"There are {len(log_files)} log files in {log_dir}. "
            f"Would you like to delete the oldest log file ({log_files[0]})? (y/N): "
        )
        if consent_cleanup.strip().lower() == "y":
            oldest_log = os.path.join(log_dir, log_files[0])
            try:
                os.remove(oldest_log)
                print(f"Deleted oldest log file: {log_files[0]}")
            except Exception as e:
                print(f"Error deleting log file: {e}")
        else:
            print("No log files were deleted.")
    progress.update(1)
    
    recommended_python = "Python 3.13.4"
    current_python = f"Python {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    if current_python != recommended_python:
        print(f"WARNING: The version running this script ({current_python}) does not match the recommended version ({recommended_python}).")
    progress.update(1)
    
    timestamp = datetime.datetime.now().strftime("%d%m%Y_%H%M%S")
    log_file_path = os.path.join(log_dir, f"log_{timestamp}.txt")
    consent_input = input(
        "This script collects non-identifiable debugging information (OS, CPU, GPU, RAM, Python Version) "
        "for logging purposes. Do you consent? (y/N): "
    )
    debug_consent = consent_input.strip().lower() == "y"
    progress.update(1)
    
    with open(log_file_path, 'w') as log_file:
        with redirect_stdout(log_file), redirect_stderr(log_file):
            if debug_consent:
                print("Debugging Information:")
                print(f"Operating System: {platform.system()} {platform.release()}")
                print(f"OS Version: {platform.version()}")
                print(f"Machine: {platform.machine()}")
                print(f"CPU: {get_cpu_name()}")
                print(f"GPU: {get_gpu_name()}")
                print(f"Total RAM: {get_total_ram()}")
                print(f"Python Version: {sys.version}")
                print("\n")
            else:
                print("User did not consent to collect debugging information.\n")
            
            for ipy_file in ipy_files:
                print(f"Running {ipy_file}...")
                start_time = datetime.datetime.now()
                while True:
                    try:
                        runpy.run_path(ipy_file, run_name="__main__")
                        break  
                    except ModuleNotFoundError as e:
                        missing_module = e.name if hasattr(e, "name") else str(e).split("'")[1]
                        sys.__stdout__.write(
                            f"Module '{missing_module}' is missing when running {ipy_file}.\n"
                            "Would you like to install it? (y/N): "
                        )
                        sys.__stdout__.flush()
                        answer = sys.__stdin__.readline().strip()
                        if answer.lower() == "y":
                            try:
                                subprocess.check_call([sys.executable, "-m", "pip", "install", missing_module])
                                sys.__stdout__.write(f"Module '{missing_module}' installed. Retrying {ipy_file}...\n")
                                sys.__stdout__.flush()
                            except Exception as e2:
                                sys.__stdout__.write(f"Error installing '{missing_module}': {e2}\n")
                                sys.__stdout__.flush()
                                break  
                        else:
                            sys.__stdout__.write("Skipping installation and continuing.\n")
                            sys.__stdout__.flush()
                            break  
                    except Exception as e:
                        print(f"Error running {ipy_file}: {e}")
                        break
                end_time = datetime.datetime.now()
                duration = (end_time - start_time).total_seconds()
                print(f"Finished {ipy_file} in {duration:.2f} seconds\n")
                progress.update(1)
            
            master_end = datetime.datetime.now()
            master_duration = (master_end - master_start).total_seconds()
            print(f"Master script executed in {master_duration:.2f} seconds")
    progress.update(1)
    progress.close()
    
    print(f"All scripts executed. Check log file: {log_file_path}")

if __name__ == "__main__":
    main()